// Code generated by sparkle. MANUALLY MODIFIED TO REMOVE WHAT IS NOT USED BY SUBSTREAMS.

package pcs

import (
	"bytes"
	"fmt"
	"math/big"

	eth "github.com/streamingfast/eth-go"
	pbcodec "github.com/streamingfast/substream-pancakeswap/pb/sf/ethereum/codec/v1"
)

const (
	FactoryAddress = "0xcA143Ce32Fe78f1f7019d7d551a6402fC5350c73"
	ZeroAddress    = "0x0000000000000000000000000000000000000000"
)

var (
	FactoryAddressBytes = eth.MustNewAddress(FactoryAddress).Bytes()
	ZeroAddressBytes    = eth.MustNewAddress(ZeroAddress).Bytes()
)

// Aliases for numerical functions
var (
	bf = func() *big.Float { return new(big.Float).SetPrec(100) }
	bi = func() *big.Int { return new(big.Int) }
)

func codecLogToEthLog(l *pbcodec.Log, idx uint32) *eth.Log {
	return &eth.Log{
		Address:    l.Address,
		Topics:     l.Topics,
		Data:       l.Data,
		Index:      l.Index,
		BlockIndex: idx,
	}
}

// Factory
// FactoryPairCreated event

type FactoryPairCreatedEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Token0 eth.Address `eth:",indexed"`
	Token1 eth.Address `eth:",indexed"`
	Pair   eth.Address `eth:""`
}

var hashFactoryPairCreatedEvent = eth.Keccak256([]byte("PairCreated(address,address,address,uint256)"))

func IsFactoryPairCreatedEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashFactoryPairCreatedEvent)
}

func NewFactoryPairCreatedEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*FactoryPairCreatedEvent, error) {
	var err error
	ev := &FactoryPairCreatedEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading token0: %w", err)
	}
	ev.Token0 = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading token1: %w", err)
	}
	ev.Token1 = f1.(eth.Address)
	ev.Pair, err = dec.DataDecoder.ReadAddress()
	if err != nil {
		return nil, fmt.Errorf("reading pair:  %w", err)
	}
	return ev, nil
}

// Pair
// PairApproval event

type PairApprovalEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Owner   eth.Address `eth:",indexed"`
	Spender eth.Address `eth:",indexed"`
	Value   *big.Int    `eth:""`
}

var hashPairApprovalEvent = eth.Keccak256([]byte("Approval(address,address,uint256)"))

func IsPairApprovalEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPairApprovalEvent)
}

func NewPairApprovalEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*PairApprovalEvent, error) {
	var err error
	ev := &PairApprovalEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading owner: %w", err)
	}
	ev.Owner = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading spender: %w", err)
	}
	ev.Spender = f1.(eth.Address)
	ev.Value, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading value:  %w", err)
	}
	return ev, nil
}

// PairBurn event

type PairBurnEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender  eth.Address `eth:",indexed"`
	Amount0 *big.Int    `eth:""`
	Amount1 *big.Int    `eth:""`
	To      eth.Address `eth:",indexed"`
}

var hashPairBurnEvent = eth.Keccak256([]byte("Burn(address,uint256,uint256,address)"))

func IsPairBurnEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPairBurnEvent)
}

func NewPairBurnEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*PairBurnEvent, error) {
	var err error
	ev := &PairBurnEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	f3, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading to: %w", err)
	}
	ev.To = f3.(eth.Address)
	return ev, nil
}

// PairMint event

type PairMintEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender  eth.Address `eth:",indexed"`
	Amount0 *big.Int    `eth:""`
	Amount1 *big.Int    `eth:""`
}

var hashPairMintEvent = eth.Keccak256([]byte("Mint(address,uint256,uint256)"))

func IsPairMintEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPairMintEvent)
}

func NewPairMintEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*PairMintEvent, error) {
	var err error
	ev := &PairMintEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0:  %w", err)
	}
	ev.Amount1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1:  %w", err)
	}
	return ev, nil
}

// PairSwap event

type PairSwapEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Sender     eth.Address `eth:",indexed"`
	Amount0In  *big.Int    `eth:""`
	Amount1In  *big.Int    `eth:""`
	Amount0Out *big.Int    `eth:""`
	Amount1Out *big.Int    `eth:""`
	To         eth.Address `eth:",indexed"`
}

var hashPairSwapEvent = eth.Keccak256([]byte("Swap(address,uint256,uint256,uint256,uint256,address)"))

func IsPairSwapEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPairSwapEvent)
}

func NewPairSwapEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*PairSwapEvent, error) {
	var err error
	ev := &PairSwapEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading sender: %w", err)
	}
	ev.Sender = f0.(eth.Address)
	ev.Amount0In, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0In:  %w", err)
	}
	ev.Amount1In, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1In:  %w", err)
	}
	ev.Amount0Out, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount0Out:  %w", err)
	}
	ev.Amount1Out, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading amount1Out:  %w", err)
	}
	f5, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading to: %w", err)
	}
	ev.To = f5.(eth.Address)
	return ev, nil
}

// PairSync event

type PairSyncEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	Reserve0 *big.Int `eth:""`
	Reserve1 *big.Int `eth:""`
}

var hashPairSyncEvent = eth.Keccak256([]byte("Sync(uint112,uint112)"))

func IsPairSyncEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPairSyncEvent)
}

func NewPairSyncEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*PairSyncEvent, error) {
	var err error
	ev := &PairSyncEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	ev.Reserve0, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserve0:  %w", err)
	}
	ev.Reserve1, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading reserve1:  %w", err)
	}
	return ev, nil
}

// PairTransfer event

type PairTransferEvent struct {
	LogAddress eth.Address
	LogIndex   int

	// Fields
	From  eth.Address `eth:",indexed"`
	To    eth.Address `eth:",indexed"`
	Value *big.Int    `eth:""`
}

var hashPairTransferEvent = eth.Keccak256([]byte("Transfer(address,address,uint256)"))

func IsPairTransferEvent(log *eth.Log) bool {
	return bytes.Equal(log.Topics[0], hashPairTransferEvent)
}

func NewPairTransferEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (*PairTransferEvent, error) {
	var err error
	ev := &PairTransferEvent{
		LogAddress: log.Address,
		LogIndex:   int(log.BlockIndex),
	}

	dec := eth.NewLogDecoder(log)
	if _, err := dec.ReadTopic(); err != nil {
		return nil, fmt.Errorf("reading topic 0: %w", err)
	}
	f0, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading from: %w", err)
	}
	ev.From = f0.(eth.Address)
	f1, err := dec.ReadTypedTopic("address")
	if err != nil {
		return nil, fmt.Errorf("reading to: %w", err)
	}
	ev.To = f1.(eth.Address)
	ev.Value, err = dec.DataDecoder.ReadBigInt()
	if err != nil {
		return nil, fmt.Errorf("reading value:  %w", err)
	}
	return ev, nil
}

func DecodeEvent(log *eth.Log, block *pbcodec.Block, trace *pbcodec.TransactionTrace) (interface{}, error) {

	if IsFactoryPairCreatedEvent(log) {
		ev, err := NewFactoryPairCreatedEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding FactoryPairCreated event: %w", err)
		}
		return ev, nil
	}

	if IsPairApprovalEvent(log) {
		ev, err := NewPairApprovalEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding PairApproval event: %w", err)
		}
		return ev, nil
	}
	if IsPairBurnEvent(log) {
		ev, err := NewPairBurnEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding PairBurn event: %w", err)
		}
		return ev, nil
	}
	if IsPairMintEvent(log) {
		ev, err := NewPairMintEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding PairMint event: %w", err)
		}
		return ev, nil
	}
	if IsPairSwapEvent(log) {
		ev, err := NewPairSwapEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding PairSwap event: %w", err)
		}
		return ev, nil
	}
	if IsPairSyncEvent(log) {
		ev, err := NewPairSyncEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding PairSync event: %w", err)
		}
		return ev, nil
	}
	if IsPairTransferEvent(log) {
		ev, err := NewPairTransferEvent(log, block, trace)
		if err != nil {
			return nil, fmt.Errorf("decoding PairTransfer event: %w", err)
		}
		return ev, nil
	}

	return nil, nil
}
